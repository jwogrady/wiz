#!/usr/bin/env bash
# ==============================================================================
# Wiz - Terminal Magic: Interactive Installer
# ==============================================================================
# Two-phase installation system:
#   Phase 1: Development tools installation (essentials, zsh, starship, node, bun, neovim)
#   Phase 2: Git identity configuration and SSH key management
#
# Features:
#   - Modular development tool installation
#   - Git identity configuration (name, email, GitHub username)
#   - SSH key management (import from Windows or archive)
#   - Global Git configuration and .gitignore
#
# Usage:
#   ./bin/install [options]
#
# Options:
#   --help            Show this help message
#   --dry-run         Show commands without executing
#   --force           Overwrite existing .env and SSH keys
#   --debug           Enable shell execution tracing (set -x)
#   --name=NAME       Set Git user.name
#   --email=EMAIL     Set Git user.email
#   --github=USER     Set GitHub username
#   --win-user=USER   Set Windows username for SSH key import (auto-detected if not provided)
#   --keys-path=PATH  Provide SSH key archive manually
#   --skip-prompt     Skip interactive continuation prompt (deprecated)
#   --skip-identity   Skip identity setup, only install modules
#   --skip-modules    Skip module installation, only setup identity
#   --module=NAME     Install only specific module(s) (comma-separated)
#   --skip=NAME       Skip specific module(s) (comma-separated)
#   --list            List all available modules
#   --graph           Show dependency graph
#   --verbose         Enable verbose output
#
# Prerequisites:
#   - git, ssh-agent, tar must be installed
#   - Intended for WSL or Linux environments
#
# ==============================================================================

set -euo pipefail
IFS=$'\n\t'

# --- Ensure running in Bash ---
if [[ -z "${BASH_VERSION:-}" ]]; then
    echo "ERROR: This script requires Bash" >&2
    exit 1
fi

# --- Source Module Base Library ---
# Note: module-base.sh automatically sources common.sh, so we only need one source statement
WIZ_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export WIZ_ROOT

# shellcheck source=lib/module-base.sh
source "${WIZ_ROOT}/lib/module-base.sh"

# --- Configuration Variables ---
DRY_RUN=0
FORCE=0
DEBUG=0
SKIP_PROMPT=1
SKIP_IDENTITY=0
SKIP_MODULES=0
KEYS_PATH=""
GIT_NAME=""
GIT_EMAIL=""
GITHUB_USERNAME=""
WIN_USER=""

# Module configuration
MODULES_DIR="${WIZ_ROOT}/lib/modules"
DISABLED_MODULES=()
REQUESTED_MODULES=()
DEFAULT_MODULES=(
    essentials
    zsh
    starship
    node
    bun
    neovim
    summary
)

# Statistics
MODULES_COMPLETED=0
MODULES_FAILED=0
MODULES_SKIPPED=0

# --- Help Message ---
show_help() {
    cat << 'EOF'
Wiz - Terminal Magic: Complete Installation & Setup

Usage:
  ./bin/install [options]

Options:
  --help              Show this help message
  --dry-run           Show commands without executing
  --force             Force reinstall of all modules
  --debug             Enable shell execution tracing
  
  Module Control:
  --skip-modules      Skip development tools installation (Phase 1)
  --skip-identity     Skip identity setup (Phase 2), only install modules
  
  Identity Setup (Phase 2):
  --name=NAME         Set Git user.name (skips prompt)
  --email=EMAIL       Set Git user.email (skips prompt)
  --github=USER       Set GitHub username (skips prompt)
  --win-user=USER     Set Windows username for SSH key import
  --keys-path=PATH    Provide SSH key archive manually
  --module=NAME       Install only specific module(s) (comma-separated)
  --skip=NAME         Skip specific module(s) (comma-separated)
  --list              List all available modules
  --graph             Show dependency graph
  --verbose           Enable verbose output

Examples:
  # Full installation (Phase 1: tools + Phase 2: identity)
  ./bin/install

  # Only install development tools (skip identity setup)
  ./bin/install --skip-identity

  # Only setup identity (skip tool installation)
  ./bin/install --skip-modules

  # Install specific modules only
  ./bin/install --skip-identity --module=node,neovim

  # Non-interactive with all options
  ./bin/install --name="John Doe" --email="john@example.com" --github="johndoe"

  # Dry-run to see what would happen
  ./bin/install --dry-run

For more information: https://github.com/jwogrady/wiz

EOF
}

# --- Parse Command-Line Arguments ---
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            "--help"|"-h")
                show_help
                exit 0
            ;;
            "--dry-run")
                DRY_RUN=1
                export WIZ_DRY_RUN=1
            ;;
            "--force")
                FORCE=1
                export WIZ_FORCE_REINSTALL=1
            ;;
            "--debug")
                DEBUG=1
            ;;
            "--verbose")
                export WIZ_VERBOSE=1
                export WIZ_LOG_LEVEL=0
            ;;
            "--skip-identity")
                SKIP_IDENTITY=1
            ;;
            "--skip-modules")
                SKIP_MODULES=1
            ;;
            "--skip-prompt")
                SKIP_PROMPT=1
                warn "--skip-prompt is deprecated, modules install automatically now"
            ;;
            "--name="*)
                GIT_NAME="${1#*=}"
            ;;
            "--email="*)
                GIT_EMAIL="${1#*=}"
            ;;
            "--github="*)
                GITHUB_USERNAME="${1#*=}"
            ;;
            "--win-user="*)
                WIN_USER="${1#*=}"
            ;;
            "--keys-path="*)
                KEYS_PATH="${1#*=}"
            ;;
            "--module="*)
                IFS=',' read -ra REQUESTED_MODULES <<< "${1#*=}"
            ;;
            "--skip="*)
                IFS=',' read -ra DISABLED_MODULES <<< "${1#*=}"
            ;;
            "--list")
                list_modules
                exit 0
            ;;
            "--graph")
                show_dependency_graph
                exit 0
            ;;
            *)
                warn "Unknown option: $1 (use --help for usage)"
            ;;
        esac
        shift
    done
    
    # Enable debug mode if requested
    if [[ $DEBUG -eq 1 ]]; then
        set -x
    fi
    
    return 0
}

# --- Requirements Check ---
check_requirements() {
    local missing=()
    local required_commands=(git ssh-agent tar)
    
    for cmd in "${required_commands[@]}"; do
        if ! command_exists "$cmd"; then
            missing+=("$cmd")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required commands: ${missing[*]}"
        error "Please install them and try again"
        exit 1
    fi
}

# --- Environment File Management ---

# validate_env: Ensure .env file has valid lines
validate_env() {
    local envfile="$1"
    
    if ! grep -q '^GIT_NAME=' "$envfile" 2>/dev/null; then
        return 1
    fi
    
    return 0
}

# validate_git_name: Validate Git name format
# Usage: validate_git_name <name>
validate_git_name() {
    local name="$1"
    
    # Name must not be empty or only whitespace
    [[ -n "${name// }" ]] || return 1
    
    # Name should be at least 2 characters
    [[ ${#name} -ge 2 ]] || return 1
    
    # Name should not contain only special characters
    [[ "$name" =~ [[:alnum:]] ]] || return 1
    
    return 0
}

# validate_email: Validate email format
# Usage: validate_email <email>
validate_email() {
    local email="$1"
    
    # Basic email format validation
    # Must contain @ and at least one character before and after
    [[ "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]] || return 1
    
    return 0
}

# validate_github_username: Validate GitHub username format
# Usage: validate_github_username <username>
validate_github_username() {
    local username="$1"
    
    # GitHub usernames can only contain alphanumeric characters and hyphens
    # Cannot start or end with a hyphen
    # Must be between 1 and 39 characters
    # Cannot contain consecutive hyphens
    [[ ${#username} -ge 1 ]] && [[ ${#username} -le 39 ]] || return 1
    
    # Single character: must be alphanumeric
    if [[ ${#username} -eq 1 ]]; then
        [[ "$username" =~ ^[a-zA-Z0-9]$ ]] || return 1
    else
        # Multiple characters: start and end with alphanumeric, middle can have hyphens
        [[ "$username" =~ ^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$ ]] || return 1
        # Check for consecutive hyphens
        [[ ! "$username" =~ -- ]] || return 1
    fi
    
    return 0
}

# write_env: Interactive environment setup
write_env() {
    local envfile="${WIZ_ROOT}/.env"
    
    # Load existing .env if present and not forcing
    if [[ -f "$envfile" ]] && [[ $FORCE -eq 0 ]]; then
        if validate_env "$envfile"; then
            log "Loading existing configuration from .env"
            # shellcheck source=/dev/null
            source "$envfile"
            return 0
        else
            warn "Existing .env appears invalid, recreating..."
        fi
    fi
    
    # Interactive prompts if values not provided via CLI
    if [[ -z "$GIT_NAME" ]]; then
        read -rp "Enter your full name (for Git commits): " GIT_NAME
    fi
    
    if [[ -z "$GIT_EMAIL" ]]; then
        read -rp "Enter your email (for Git commits): " GIT_EMAIL
    fi
    
    if [[ -z "$GITHUB_USERNAME" ]]; then
        read -rp "Enter your GitHub username: " GITHUB_USERNAME
    fi
    
    # Auto-detect Windows username if not provided (no prompt needed)
    if [[ -z "$WIN_USER" ]]; then
        WIN_USER="$(detect_windows_user 2>/dev/null || echo "")"
        if [[ -n "$WIN_USER" ]]; then
            debug "Auto-detected Windows username: $WIN_USER"
        fi
    fi
    
    # Validate inputs
    if [[ -z "$GIT_NAME" ]] || [[ -z "$GIT_EMAIL" ]] || [[ -z "$GITHUB_USERNAME" ]]; then
        error "Name, email, and GitHub username are required"
        exit 1
    fi
    
    # Validate format
    if ! validate_git_name "$GIT_NAME"; then
        error "Invalid name format. Please enter your full name."
        exit 1
    fi
    
    if ! validate_email "$GIT_EMAIL"; then
        error "Invalid email format. Please enter a valid email address."
        exit 1
    fi
    
    if ! validate_github_username "$GITHUB_USERNAME"; then
        error "Invalid GitHub username format. Username must contain only alphanumeric characters and hyphens."
        exit 1
    fi
    
    # Write .env file
    log "Writing configuration to .env..."
    
    cat > "$envfile" << EOF
# Wiz Configuration
# Generated on $(date -u +"%Y-%m-%d %H:%M:%S UTC")

GIT_NAME="$GIT_NAME"
GIT_EMAIL="$GIT_EMAIL"
GITHUB_USERNAME="$GITHUB_USERNAME"
WIN_USER="$WIN_USER"
EOF
    
    success "Configuration saved to .env"
    
    # Source the file we just created
    # shellcheck source=/dev/null
    source "$envfile"
}

# --- Git Configuration ---

configure_git() {
    log "Configuring Git..."
    
    # Set global Git identity
    run "git config --global user.name '$GIT_NAME'"
    run "git config --global user.email '$GIT_EMAIL'"
    
    # Set useful Git defaults
    run "git config --global init.defaultBranch main"
    run "git config --global pull.rebase false"
    run "git config --global core.autocrlf input"
    
    # Create global .gitignore
    local gitignore="${HOME}/.gitignore_global"
    
    if [[ ! -f "$gitignore" ]] || [[ $FORCE -eq 1 ]]; then
        log "Creating global .gitignore..."
        
        cat > "$gitignore" << 'EOF'
# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Editor files
*.swp
*.swo
*~
.vscode/
.idea/

# Environment
.env
.env.local

# Node
node_modules/
npm-debug.log*

# Python
__pycache__/
*.py[cod]
venv/
.python-version
EOF
        
        run "git config --global core.excludesfile '$gitignore'"
        success "Global .gitignore created"
    else
        debug "Global .gitignore already exists"
    fi
    
    success "Git configured for: $GIT_NAME <$GIT_EMAIL>"
}

# --- SSH Key Management ---

# has_ssh_keys: Check if SSH keys exist (cached result)
has_ssh_keys() {
    local ssh_dir="${1:-${HOME}/.ssh}"
    [[ -d "$ssh_dir" ]] || return 1
    
    # Quick check for any private key file
    for key in "$ssh_dir"/*; do
        [[ -f "$key" ]] || continue
        [[ "$key" == *.pub ]] && continue
        [[ "$key" == *known_hosts* ]] && continue
        [[ "$key" == *config* ]] && continue
        return 0
    done
    
    return 1
}

# load_ssh_keys_to_agent: Load all SSH keys into the agent
# Only prompts for passphrase if keys aren't already loaded
load_ssh_keys_to_agent() {
    local ssh_dir="${HOME}/.ssh"
    [[ -d "$ssh_dir" ]] || return 0
    
    if ! command_exists ssh-agent || ! command_exists ssh-add; then
        return 0
    fi
    
    # Start agent if not running
    if [[ -z "${SSH_AUTH_SOCK:-}" ]] || ! ssh-add -l >/dev/null 2>&1; then
        eval "$(ssh-agent -s)" >/dev/null 2>&1 || return 0
        # Export SSH agent variables so they persist in the current shell
        export SSH_AUTH_SOCK SSH_AGENT_PID
    fi
    
    # Get list of already-loaded keys (fingerprints)
    local loaded_fingerprints
    loaded_fingerprints=$(ssh-add -l 2>/dev/null | awk '{print $2}' || echo "")
    
    # Add all private keys to the agent (including named keys like id_vultr, id_jwogrady)
    local keys_loaded=0
    local keys_skipped=0
    for key in "$ssh_dir"/*; do
        [[ -f "$key" ]] || continue
        [[ "$key" == *.pub ]] && continue
        [[ "$key" == *known_hosts* ]] && continue
        [[ "$key" == *config* ]] && continue
        
        # Check if key is already loaded by comparing fingerprints
        local key_fingerprint
        key_fingerprint=$(ssh-keygen -lf "$key" 2>/dev/null | awk '{print $2}' || echo "")
        
        if [[ -n "$key_fingerprint" ]] && [[ "$loaded_fingerprints" == *"$key_fingerprint"* ]]; then
            debug "SSH key already loaded: $(basename "$key")"
            keys_skipped=$((keys_skipped + 1))
            continue
        fi
        
        # Try to add key (will prompt for password if needed)
        # Redirect stdin from /dev/tty to allow passphrase entry if needed
        if [[ -t 0 ]] && [[ -t 1 ]]; then
            # Interactive terminal - allow passphrase prompt
            if ssh-add "$key" 2>/dev/null; then
                keys_loaded=$((keys_loaded + 1))
            else
                debug "Failed to add SSH key: $(basename "$key") (may require passphrase)"
            fi
        else
            # Non-interactive - skip keys that need passphrase
            if ssh-add "$key" 2>/dev/null; then
                keys_loaded=$((keys_loaded + 1))
            else
                debug "Skipping SSH key that requires passphrase: $(basename "$key")"
            fi
        fi
    done
    
    if [[ $keys_loaded -gt 0 ]]; then
        debug "Loaded $keys_loaded SSH key(s) into agent"
    fi
    if [[ $keys_skipped -gt 0 ]]; then
        debug "Skipped $keys_skipped already-loaded SSH key(s)"
    fi
}

# ensure_ssh_directory: Ensure .ssh directory exists with correct permissions
# Usage: ensure_ssh_directory <ssh_dir>
ensure_ssh_directory() {
    local ssh_dir="$1"
    
    if [[ ! -d "$ssh_dir" ]]; then
        mkdir -p "$ssh_dir"
        run "chmod 700 '$ssh_dir'"
    else
        # Verify permissions are correct (chmod is idempotent, but we log it)
        run "chmod 700 '$ssh_dir'"
    fi
}

# import_keys_from_archive: Import SSH keys from archive file
# Usage: import_keys_from_archive <archive_path> <ssh_dir>
import_keys_from_archive() {
    local archive_path="$1"
    local ssh_dir="$2"
    
    log "Importing SSH keys from archive: $archive_path"
    
    if [[ $FORCE -eq 1 ]] || [[ ! -f "$ssh_dir/id_ed25519" ]]; then
        if extract_ssh_keys_from_archive "$archive_path" "$ssh_dir"; then
            success "SSH keys imported from archive: $archive_path"
            return 0
        else
            error "Failed to extract SSH keys from archive: $archive_path"
            error "Please verify the archive format and permissions"
            return 1
        fi
    else
        debug "SSH keys already exist, skipping import (use --force to overwrite)"
        return 0
    fi
}

# import_keys_from_directory: Import SSH keys from directory
# Usage: import_keys_from_directory <source_dir> <ssh_dir> <description>
import_keys_from_directory() {
    local source_dir="$1"
    local ssh_dir="$2"
    local description="$3"
    
    log "Importing SSH keys from $description: $source_dir"
    
    local keys_imported=0
    for keyfile in "$source_dir"/id_*; do
        [[ -f "$keyfile" ]] || continue
        
        local basename
        basename="$(basename "$keyfile")"
        local target="$ssh_dir/$basename"
        
        if [[ ! -f "$target" ]] || [[ $FORCE -eq 1 ]]; then
            if run "cp '$keyfile' '$target'"; then
                # Set correct permissions based on file type
                if [[ "$basename" != *.pub ]]; then
                    run "chmod 600 '$target'"
                    keys_imported=$((keys_imported + 1))
                else
                    run "chmod 644 '$target'"
                fi
            else
                warn "Failed to copy key: $basename"
            fi
        fi
    done
    
    if [[ $keys_imported -gt 0 ]]; then
        success "SSH keys imported from $description"
        return 0
    else
        debug "SSH keys already present, skipping import"
        return 0
    fi
}

# import_keys_from_windows_home: Import keys from Windows user home directory
# Usage: import_keys_from_windows_home <win_user> <ssh_dir>
import_keys_from_windows_home() {
    local win_user="$1"
    local ssh_dir="$2"
    
    # By convention, keys are in C:\Users\{WIN_USER}\keys.tar.gz
    local keys_archive="/mnt/c/Users/${win_user}/keys.tar.gz"
    
    if [[ -f "$keys_archive" ]]; then
        if import_keys_from_archive "$keys_archive" "$ssh_dir"; then
            return 0
        else
            return 1
        fi
    fi
    
    # Fallback: Check Windows .ssh directory
    local win_ssh_dir="/mnt/c/Users/$win_user/.ssh"
    if [[ -d "$win_ssh_dir" ]]; then
        import_keys_from_directory "$win_ssh_dir" "$ssh_dir" "Windows"
        return 0
    fi
    
    return 1
}

# generate_new_ssh_key: Generate a new SSH key if none exists
# Usage: generate_new_ssh_key <ssh_dir> <email>
generate_new_ssh_key() {
    local ssh_dir="$1"
    local email="$2"
    
    if ! has_ssh_keys "$ssh_dir"; then
        warn "No SSH keys found. Generating new key..."
        run "ssh-keygen -t ed25519 -C '$email' -f '$ssh_dir/id_ed25519' -N ''"
        success "New SSH key generated"
        
        echo ""
        log "Add this public key to GitHub:"
        cat "$ssh_dir/id_ed25519.pub"
        echo ""
    else
        debug "SSH keys already present"
    fi
}

import_ssh_keys() {
    local ssh_dir="${HOME}/.ssh"
    
    # Ensure .ssh directory exists with correct permissions
    ensure_ssh_directory "$ssh_dir"
    
    # Check if keys already exist (from bootstrap import)
    if has_ssh_keys "$ssh_dir" && [[ $FORCE -eq 0 ]]; then
        debug "SSH keys already present (from bootstrap), skipping import"
        return 0
    fi
    
    # Priority 1: Import from explicit KEYS_PATH if provided
    if [[ -n "$KEYS_PATH" ]] && [[ -f "$KEYS_PATH" ]]; then
        if import_keys_from_archive "$KEYS_PATH" "$ssh_dir"; then
            return 0
        else
            return 1
        fi
    fi
    
    # Priority 2: Import from Windows user home directory (by convention)
    # Auto-detect Windows username if not provided
    local win_user="${WIN_USER:-}"
    
    if [[ -z "$win_user" ]]; then
        win_user="$(detect_windows_user 2>/dev/null || echo "")"
    fi
    
    # Skip if we couldn't detect a username
    if [[ -z "$win_user" ]]; then
        debug "Windows username not detected, skipping Windows key import"
    elif import_keys_from_windows_home "$win_user" "$ssh_dir"; then
        return 0
    fi
    
    # Generate new SSH key if none exists
    generate_new_ssh_key "$ssh_dir" "$GIT_EMAIL"
}

# configure_ssh_agent: Setup ssh-agent persistence
configure_ssh_agent() {
    log "Configuring ssh-agent..."
    
    local zshrc="${HOME}/.zshrc"
    local bashrc="${HOME}/.bashrc"
    
    # Improved SSH agent config that works for both bash and zsh
    # Uses better key detection and avoids duplicate loading
    local ssh_agent_config='
# --- Wiz SSH Agent Configuration ---
# Start ssh-agent if not running
if [ -z "${SSH_AUTH_SOCK:-}" ] || ! ssh-add -l >/dev/null 2>&1; then
    eval "$(ssh-agent -s)" >/dev/null 2>&1
    export SSH_AUTH_SOCK SSH_AGENT_PID
    
    # Get list of already-loaded key fingerprints
    loaded_fingerprints=$(ssh-add -l 2>/dev/null | awk '"'"'{print $2}'"'"' || echo "")
    
    # Load all private keys that aren't already loaded
    for key in "${HOME}/.ssh/"*; do
        [[ -f "$key" ]] || continue
        [[ "$key" == *.pub ]] && continue
        [[ "$key" == *known_hosts* ]] && continue
        [[ "$key" == *config* ]] && continue
        
        # Check if key is already loaded by fingerprint
        if command -v ssh-keygen >/dev/null 2>&1; then
            key_fingerprint=$(ssh-keygen -lf "$key" 2>/dev/null | awk '"'"'{print $2}'"'"' || echo "")
            if [[ -n "$key_fingerprint" ]] && [[ "$loaded_fingerprints" == *"$key_fingerprint"* ]]; then
                continue
            fi
        fi
        
        # Try to add key (will prompt for passphrase if needed)
        ssh-add "$key" 2>/dev/null || true
    done
fi
# --- End Wiz SSH Agent Configuration ---
'
    
    # Add to .bashrc - ensure it's early in the file for proper initialization
    if [[ -f "$bashrc" ]]; then
        # Remove any existing SSH agent config first
        if grep -q "Wiz SSH Agent" "$bashrc" 2>/dev/null; then
            sed -i '/# --- Wiz SSH Agent Configuration ---/,/# --- End Wiz SSH Agent Configuration ---/d' "$bashrc"
        fi
        # Prepend to file (SSH agent should load early)
        { echo "$ssh_agent_config"; cat "$bashrc"; } > "$bashrc.tmp" && mv "$bashrc.tmp" "$bashrc"
        debug "SSH agent config added to .bashrc"
    fi
    
    # Add to .zshrc if it exists - ensure it's early in the file
    if [[ -f "$zshrc" ]]; then
        # Remove any existing SSH agent config first
        if grep -q "Wiz SSH Agent" "$zshrc" 2>/dev/null; then
            sed -i '/# --- Wiz SSH Agent Configuration ---/,/# --- End Wiz SSH Agent Configuration ---/d' "$zshrc"
        fi
        
        # Insert early in file (after Oh My Zsh setup but before other tools)
        # Check if Oh My Zsh is configured
        if grep -q "^plugins=" "$zshrc" 2>/dev/null; then
        # Insert after plugins line using a reliable method
            local plugins_line
            plugins_line=$(grep -n "^plugins=" "$zshrc" | head -1 | cut -d: -f1)
            if [[ -n "$plugins_line" ]]; then
                # Create temp file with SSH agent config, then insert using awk
                echo "$ssh_agent_config" > /tmp/ssh_agent_insert.tmp
                awk -v line="$plugins_line" '
                    NR == line { print; while ((getline < "/tmp/ssh_agent_insert.tmp") > 0) print; close("/tmp/ssh_agent_insert.tmp"); next }
                    { print }
                ' "$zshrc" > "$zshrc.tmp" && mv "$zshrc.tmp" "$zshrc"
                rm -f /tmp/ssh_agent_insert.tmp
            else
                # Prepend to file
                { echo "$ssh_agent_config"; cat "$zshrc"; } > "$zshrc.tmp" && mv "$zshrc.tmp" "$zshrc"
            fi
        else
            # Prepend to file if no Oh My Zsh found
            { echo "$ssh_agent_config"; cat "$zshrc"; } > "$zshrc.tmp" && mv "$zshrc.tmp" "$zshrc"
        fi
        debug "SSH agent config added to .zshrc"
    fi
    
    # Load SSH keys in current session if ssh-agent is available
    # This will check if keys are already loaded and skip them
    load_ssh_keys_to_agent
    
    success "SSH agent configured"
}

# ==============================================================================
# MODULE INSTALLATION FUNCTIONS
# ==============================================================================

# init_config: Initialize configuration and environment
init_config() {
    # Ensure log directory exists
    mkdir -p "$LOG_DIR"
    
    # Ensure state directory exists
    mkdir -p "$WIZ_STATE_DIR"
    
    # Note: .env is loaded in main() for Phase 2 (identity setup), but this function
    # is for Phase 1 (module installation) initialization, so .env may not exist yet
    if [[ -f "${WIZ_ROOT}/.env" ]]; then
        # shellcheck source=/dev/null
        source "${WIZ_ROOT}/.env"
        debug "Loaded configuration from .env"
    fi
    
    return 0
}

list_modules() {
    echo "Available Modules:"
    echo "=================="
    echo ""
    
    for module_file in "${MODULES_DIR}"/install_*.sh; do
        [[ -f "$module_file" ]] || continue
        
        local module_name
        module_name="$(basename "$module_file" .sh)"
        module_name="${module_name#install_}"
        
        (
            # shellcheck source=/dev/null
            source "$module_file"
            
            printf "  %-15s v%-8s %s\n" \
                "$module_name" \
                "${MODULE_VERSION:-unknown}" \
                "${MODULE_DESCRIPTION:-No description}"
        )
    done
    
    echo ""
}

is_disabled() {
    local module="$1"
    
    for disabled in "${DISABLED_MODULES[@]+"${DISABLED_MODULES[@]}"}"; do
        [[ "$module" == "$disabled" ]] && return 0
    done
    
    return 1
}

execute_module_wrapper() {
    local module="$1"
    local module_file="${MODULES_DIR}/install_${module}.sh"
    
    if [[ ! -f "$module_file" ]]; then
        error "Module not found: $module"
        return 1
    fi
    
    if is_disabled "$module"; then
        log "Module disabled: $module"
        MODULES_SKIPPED=$((MODULES_SKIPPED + 1))
        return 0
    fi
    
    if is_module_complete "$module" && [[ "${WIZ_FORCE_REINSTALL:-0}" != "1" ]]; then
        log "Module already completed: $module (use --force to reinstall)"
        MODULES_SKIPPED=$((MODULES_SKIPPED + 1))
        return 0
    fi
    
    log "Executing module: $module"
    
    if (
        # shellcheck source=/dev/null
        source "$module_file"
        execute_module "$module"
    ); then
        MODULES_COMPLETED=$((MODULES_COMPLETED + 1))
        return 0
    else
        MODULES_FAILED=$((MODULES_FAILED + 1))
        error "Module failed: $module"
        
        if [[ "${WIZ_STOP_ON_ERROR:-1}" == "1" ]]; then
            error "Stopping due to error (set WIZ_STOP_ON_ERROR=0 to continue)"
            return 1
        fi
        
        return 0
    fi
}

show_statistics() {
    local total=$((MODULES_COMPLETED + MODULES_FAILED + MODULES_SKIPPED))
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "  INSTALLATION STATISTICS"
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
    printf "  Total modules:    %d\n" "$total"
    printf "  âœ“ Completed:      %d\n" "$MODULES_COMPLETED"
    printf "  âŠ˜ Skipped:        %d\n" "$MODULES_SKIPPED"
    printf "  âœ– Failed:         %d\n" "$MODULES_FAILED"
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo ""
}

run_module_installation() {
    log "Wiz Module Installation v0.2.0"
    echo ""
    
    init_config
    mkdir -p "$WIZ_STATE_DIR"
    
    if [[ ${#REQUESTED_MODULES[@]} -eq 0 ]]; then
        REQUESTED_MODULES=("${DEFAULT_MODULES[@]}")
    fi
    
    # Display modules with proper formatting (IFS affects array joining)
    local modules_display
    local old_ifs="$IFS"
    IFS=' '
    modules_display="${REQUESTED_MODULES[*]}"
    IFS="$old_ifs"
    
    log "Modules to install: ${modules_display}"
    
    if [[ ${#DISABLED_MODULES[@]} -gt 0 ]]; then
        IFS=' '
        local disabled_display="${DISABLED_MODULES[*]}"
        IFS="$old_ifs"
        log "Modules to skip: ${disabled_display}"
    fi
    echo ""
    
    if ! verify_dependencies; then
        error "Dependency verification failed"
        return 1
    fi
    
    log "Resolving dependencies..."
    
    local ordered_modules
    if ordered_modules=$(get_install_order "${REQUESTED_MODULES[@]}"); then
        debug "Installation order: $ordered_modules"
    else
        error "Failed to resolve dependencies"
        return 1
    fi
    
    log "Starting module installation..."
    echo ""
    
    # Convert space-separated string to array (temporarily restore default IFS)
    local module_array
    local old_ifs="$IFS"
    IFS=' '
    read -ra module_array <<< "$ordered_modules"
    IFS="$old_ifs"
    
    local total=${#module_array[@]}
    local current=0
    
    for module in "${module_array[@]}"; do
        current=$((current + 1))
        
        progress_bar "$current" "$total" "[$current/$total] $module"
        
        if ! execute_module_wrapper "$module"; then
            error "Module execution failed: $module"
            
            if [[ "${WIZ_STOP_ON_ERROR:-1}" == "1" ]]; then
                return 1
            fi
        fi
    done
    
    show_statistics
    
    if [[ $MODULES_FAILED -eq 0 ]]; then
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        success "  Module installation completed successfully!"
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        return 0
    else
        error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        error "  Module installation completed with errors"
        error "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        return 1
    fi
}

# ==============================================================================
# MAIN WORKFLOW
# ==============================================================================

main() {
    # Parse arguments
    parse_args "$@"
    
    # Enable debug mode if requested (must be after parse_args)
    if [[ $DEBUG -eq 1 ]]; then
        set -x
    fi
    
    # Show banner
    show_banner
    
    log "Starting Wiz installation..."
    log "Log file: ${LOG_FILE:-logs/install_$(date +%F).log}"
    echo ""
    
    # PHASE 1: Development Tools Installation (unless skipped)
    if [[ $SKIP_MODULES -eq 0 ]]; then
        log "â”â”â” PHASE 1: Development Tools Installation â”â”â”"
        echo ""
        
        if ! run_module_installation; then
            error "Module installation failed"
            exit 1
        fi
    fi
    
    # PHASE 2: Identity & SSH Setup (unless skipped)
    if [[ $SKIP_IDENTITY -eq 0 ]]; then
        if [[ $SKIP_MODULES -eq 0 ]]; then
            log "â”â”â” PHASE 2: Identity & SSH Setup â”â”â”"
            echo ""
        fi
        
        # Check prerequisites
        check_requirements
        
        # Load .env early if it exists (may contain WIN_USER from bootstrap)
        if [[ -f "${WIZ_ROOT}/.env" ]]; then
            # shellcheck source=/dev/null
            source "${WIZ_ROOT}/.env"
            debug "Loaded existing .env configuration"
        fi
        
        # Interactive setup
        write_env
        echo ""
        
        # Configure Git
        configure_git
        echo ""
        
        # Setup SSH (import keys if needed, then configure agent)
        import_ssh_keys
        configure_ssh_agent
        echo ""
        
        # Success message
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        success "  Identity setup complete!"
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        log "Git configured as: ${BOLD}$GIT_NAME <$GIT_EMAIL>${NC}"
        log "GitHub username: ${BOLD}$GITHUB_USERNAME${NC}"
        log "SSH keys: ${BOLD}$HOME/.ssh/${NC}"
        echo ""
    fi
    
    # Final Success Message
    if [[ $SKIP_IDENTITY -eq 1 ]]; then
        # Phase 1 complete - show message (no prompt, user can run Phase 2 manually)
        echo ""
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        success "  PHASE 1 COMPLETE: Development Tools Installation âœ“"
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        log "To configure Git identity and SSH keys later, run:"
        log "  ${BOLD}cd ~/wiz && ./bin/install --skip-modules${NC}"
        echo ""
    else
        # Full installation complete
        echo ""
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        success "  ğŸŒŒ WIZ INSTALLATION COMPLETE! âœ¨"
        success "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        
        log "Next steps:"
        log "  1. Review configuration files in ~/.config/"
        log "  2. Check installed tools: git, docker, nvim, node, etc."
        echo ""
        
        # Automatically reload shell
        log "${BOLD}âœ¨ Reloading shell to apply all changes...${NC}"
        echo ""
        
        # Exec into new shell (replaces current process)
        if command_exists zsh && [[ -f "$HOME/.zshrc" ]]; then
            exec zsh
        elif [[ -f "$HOME/.bashrc" ]]; then
            exec bash
        else
            log "Please restart your terminal manually to apply changes."
        fi
    fi
}

# --- Execute Main ---
main "$@"

